import './style.css'
import { WebRTCClient } from './webrtc-client'
import type { GameState } from './webrtc-client'

// ÌÖåÌä∏Î¶¨Ïä§ UI Î†åÎçîÎßÅ
const app = document.querySelector<HTMLDivElement>('#app')!
app.innerHTML = `
  <div class="h-screen tetris-gradient flex items-center justify-center p-4 overflow-hidden">
    <div class="w-full h-full max-w-7xl">
      <!-- Í≤åÏûÑ Ïª®ÌÖåÏù¥ÎÑà -->
      <div class="glass-effect rounded-3xl p-6 shadow-2xl h-full flex flex-col">
        <!-- ÌîåÎ†àÏù¥Ïñ¥ Ï†ïÎ≥¥ Ìó§Îçî -->
        <div class="flex justify-between items-center mb-4 p-3 glass-effect rounded-2xl flex-shrink-0">
          <div class="text-xl font-bold text-white" id="player-name">Player</div>
          <div class="text-base text-white/80">Room: <span id="room-id" class="font-mono bg-white/20 px-2 py-1 rounded-lg">-</span></div>
        </div>
        
        <!-- Î©îÏù∏ Í≤åÏûÑ UI -->
        <div class="flex-1 flex flex-col lg:flex-row gap-4 min-h-0">
          <!-- ÏôºÏ™Ω Ìå®ÎÑê -->
          <div class="space-y-4 flex-shrink-0 lg:w-48 order-2 lg:order-1">
            <!-- Hold ÏÑπÏÖò -->
            <div class="tetris-panel p-3">
              <div class="text-lg font-bold text-white mb-2">Hold</div>
              <canvas id="hold-canvas" width="80" height="80" class="tetris-canvas mx-auto" tabindex="0"></canvas>
            </div>
            
            <!-- ÌîåÎ†àÏù¥Ïñ¥ Î™©Î°ù -->
            <div class="tetris-panel p-3">
              <div class="text-lg font-bold text-white mb-2">Players</div>
              <div id="players-list" class="space-y-1 max-h-32 overflow-y-auto"></div>
            </div>
          </div>
          
          <!-- Î©îÏù∏ Í≤åÏûÑ ÏòÅÏó≠ -->
          <div class="flex-1 flex justify-center items-center order-1 lg:order-2">
            <!-- Î©îÏù∏ Í≤åÏûÑ -->
            <div class="flex justify-center items-center">
              <div class="relative">
                <canvas id="tetris-canvas" width="240" height="400" class="tetris-canvas shadow-2xl" tabindex="0"></canvas>
                <div class="absolute inset-0 flex items-center justify-center pointer-events-none">
                  <div class="text-4xl font-bold text-white/20 hidden" id="game-over-text">GAME OVER</div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Ïò§Î•∏Ï™Ω Ìå®ÎÑê -->
          <div class="space-y-4 flex-shrink-0 lg:w-48 order-3">
            <!-- Next ÏÑπÏÖò -->
            <div class="tetris-panel p-3">
              <div class="text-lg font-bold text-white mb-2">Next</div>
              <canvas id="next-canvas" width="80" height="80" class="tetris-canvas mx-auto" tabindex="0"></canvas>
            </div>
            
            <!-- Í≤åÏûÑ Ï†ïÎ≥¥ -->
            <div class="tetris-panel p-3">
              <div class="text-xl font-bold text-white mb-4">Score: <span id="score" class="text-green-400">0</span></div>
              <div class="space-y-3">
                <button id="start-btn" class="tetris-button w-full text-sm py-2">Start Game</button>
                <button id="share-btn" class="tetris-button w-full bg-gradient-to-r from-green-600 to-blue-600 text-sm py-2">Share Room</button>
              </div>
            </div>
            
            <!-- Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥Îì§ -->
            <div class="tetris-panel p-3">
              <div class="text-lg font-bold text-white mb-3 text-center">Other Players</div>
              <div id="other-players-grid" class="grid gap-2"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Î∞© ÏÉùÏÑ±/Ï∞∏Í∞Ä Î™®Îã¨ -->
  <div id="room-modal" class="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50 hidden">
    <div class="tetris-panel max-w-md w-full mx-4 p-8">
      <h2 class="text-3xl font-bold text-white mb-8 text-center">üéÆ Tetris Multiplayer</h2>
      
      <div class="space-y-6">
        <div>
          <label for="nickname" class="block text-lg font-semibold text-white mb-2">Nickname</label>
          <input type="text" id="nickname" placeholder="Enter your nickname" maxlength="15" class="tetris-input">
        </div>
        
        <div class="flex gap-4">
          <button id="create-room-btn" class="tetris-button flex-1">Create Room</button>
          <button id="join-room-btn" class="tetris-button flex-1 bg-gradient-to-r from-green-600 to-blue-600">Join Room</button>
        </div>
        
        <div id="room-input-group" class="space-y-4 hidden">
          <div>
            <label for="room-code" class="block text-lg font-semibold text-white mb-2">Room Code</label>
            <input type="text" id="room-code" placeholder="Enter room code" class="tetris-input">
          </div>
          <button id="join-room-submit-btn" class="tetris-button w-full bg-gradient-to-r from-orange-600 to-red-600">Join Room</button>
        </div>
      </div>
    </div>
  </div>
`;

// ÌÖåÌä∏Î¶¨Ïä§ ÏÉÅÏàò Î∞è ÌÉÄÏûÖ
const COLS = 10;
const ROWS = 20;
const BLOCK_SIZE = 36; // Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ÏôÄ ÎßûÏ∂§ (36x20=720, 36x10=360)

// WebRTC Í¥ÄÎ†® Î≥ÄÏàò
let webrtcClient: WebRTCClient | null = null;
const SIGNALING_SERVER_URL = 'ws://localhost:3001';

// ÌÖåÌä∏Î°úÎØ∏ÎÖ∏ Î™®Ïñë Ï†ïÏùò (ÌöåÏ†Ñ Ìè¨Ìï®)
const TETROMINOS = [
  // I
  [
    [ [0,1], [1,1], [2,1], [3,1] ],
    [ [2,0], [2,1], [2,2], [2,3] ],
    [ [0,2], [1,2], [2,2], [3,2] ],
    [ [1,0], [1,1], [1,2], [1,3] ],
  ],
  // J
  [
    [ [0,0], [0,1], [1,1], [2,1] ],
    [ [1,0], [2,0], [1,1], [1,2] ],
    [ [0,1], [1,1], [2,1], [2,2] ],
    [ [1,0], [1,1], [0,2], [1,2] ],
  ],
  // L
  [
    [ [2,0], [0,1], [1,1], [2,1] ],
    [ [1,0], [1,1], [1,2], [2,2] ],
    [ [0,1], [1,1], [2,1], [0,2] ],
    [ [0,0], [1,0], [1,1], [1,2] ],
  ],
  // O
  [
    [ [1,0], [2,0], [1,1], [2,1] ],
    [ [1,0], [2,0], [1,1], [2,1] ],
    [ [1,0], [2,0], [1,1], [2,1] ],
    [ [1,0], [2,0], [1,1], [2,1] ],
  ],
  // S
  [
    [ [1,0], [2,0], [0,1], [1,1] ],
    [ [1,0], [1,1], [2,1], [2,2] ],
    [ [1,1], [2,1], [0,2], [1,2] ],
    [ [0,0], [0,1], [1,1], [1,2] ],
  ],
  // T
  [
    [ [1,0], [0,1], [1,1], [2,1] ],
    [ [1,0], [1,1], [2,1], [1,2] ],
    [ [0,1], [1,1], [2,1], [1,2] ],
    [ [1,0], [0,1], [1,1], [1,2] ],
  ],
  // Z
  [
    [ [0,0], [1,0], [1,1], [2,1] ],
    [ [2,0], [1,1], [2,1], [1,2] ],
    [ [0,1], [1,1], [1,2], [2,2] ],
    [ [1,0], [0,1], [1,1], [0,2] ],
  ],
];
const COLORS = [
  '#00f0f0', // I
  '#0000f0', // J
  '#f0a000', // L
  '#f0f000', // O
  '#00f000', // S
  '#a000f0', // T
  '#f00000', // Z
];

type Cell = number | null; // null: ÎπàÏπ∏, 0~6: ÌÖåÌä∏Î°úÎØ∏ÎÖ∏ ÏÉâ

type Tetromino = {
  shape: number[][][];
  color: string;
  rotation: number;
  x: number;
  y: number;
  type: number;
};

// Í≤åÏûÑ ÏÉÅÌÉú
let board: Cell[][] = [];
let current: Tetromino | null = null;
let next: Tetromino | null = null;
let hold: Tetromino | null = null;
let holdUsed = false;
let score = 0;
let gameOver = false;
let dropInterval = 500;
let dropTimer: number | undefined;

// Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Í¥ÄÎ†® Î≥ÄÏàò (WebSocket Ï†úÍ±∞)
let playerId = '';
let playerName = '';
let roomId = '';
let players: { [key: string]: { name: string; board: Cell[][]; score: number; current: Tetromino | null; next: Tetromino | null; gameOver: boolean; gameStartTime?: number } } = {};
let otherPlayerCanvases: { [key: string]: HTMLCanvasElement } = {};
let gameStateInterval: number | null = null;
const GAME_START_TIMEOUT = 10000; // 10Ï¥à ÌõÑ Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥Îäî ÏãúÏûë Î∂àÍ∞Ä

// DOM ÏöîÏÜåÎì§
const playerNameEl = document.getElementById('player-name')!;
const roomIdEl = document.getElementById('room-id')!;
const playersListEl = document.getElementById('players-list')!;
const otherPlayersGridEl = document.getElementById('other-players-grid')!;
const roomModalEl = document.getElementById('room-modal')!;
const nicknameInput = document.getElementById('nickname') as HTMLInputElement;
const roomCodeInput = document.getElementById('room-code') as HTMLInputElement;
const createRoomBtn = document.getElementById('create-room-btn')!;
const joinRoomBtn = document.getElementById('join-room-btn')!;
const joinRoomSubmitBtn = document.getElementById('join-room-submit-btn')!;
const shareBtn = document.getElementById('share-btn')!;

const canvas = document.getElementById('tetris-canvas') as HTMLCanvasElement;
canvas.width = COLS * BLOCK_SIZE;
canvas.height = ROWS * BLOCK_SIZE;
const ctx = canvas.getContext('2d')!;
const holdCanvas = document.getElementById('hold-canvas') as HTMLCanvasElement;
const holdCtx = holdCanvas.getContext('2d')!;
const nextCanvas = document.getElementById('next-canvas') as HTMLCanvasElement;
const nextCtx = nextCanvas.getContext('2d')!;
const scoreEl = document.getElementById('score')!;
const startBtn = document.getElementById('start-btn')!;

function resetBoard() {
  board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
}

function randomTetromino(): Tetromino {
  const type = Math.floor(Math.random() * TETROMINOS.length);
  return {
    shape: TETROMINOS[type],
    color: COLORS[type],
    rotation: 0,
    x: 3,
    y: 0,
    type,
  };
}

function drawCell(x: number, y: number, color: string) {
  ctx.fillStyle = color;
  ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
  ctx.strokeStyle = '#222';
  ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
}

function drawBoard() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Î≥¥Îìú
  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      if (board[y][x] !== null) {
        drawCell(x, y, COLORS[board[y][x]!]);
      }
    }
  }
  // ÌòÑÏû¨ Î∏îÎ°ù
  if (current) {
    for (const [dx, dy] of current.shape[current.rotation]) {
      const px = current.x + dx;
      const py = current.y + dy;
      if (py >= 0 && py < ROWS && px >= 0 && px < COLS) {
        drawCell(px, py, current.color);
      }
    }
  }
  
  // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥: Í≤åÏûÑ ÏÉÅÌÉú Ï†ÑÏÜ° (Í≤åÏûÑ ÏßÑÌñâ Ï§ëÏùº ÎïåÎßå, Îçî ÏûêÏ£º ÏóÖÎç∞Ïù¥Ìä∏)
  if (current && !gameOver) {
    // ÏÉÅÌÉú Ï†ÄÏû•ÏùÑ Î≥ÑÎèÑÎ°ú Ï≤òÎ¶¨ÌïòÏó¨ Î†åÎçîÎßÅ ÏÑ±Îä• Ìñ•ÏÉÅ
    setTimeout(() => saveGameState(), 0);
  }
}

function drawHold() {
  holdCtx.clearRect(0, 0, holdCanvas.width, holdCanvas.height);
  if (hold) {
    const blockSize = 20;
    const offsetX = (holdCanvas.width - 4 * blockSize) / 2;
    const offsetY = (holdCanvas.height - 4 * blockSize) / 2;
    
    for (const [dx, dy] of hold.shape[0]) {
      const x = offsetX + dx * blockSize;
      const y = offsetY + dy * blockSize;
      holdCtx.fillStyle = hold.color;
      holdCtx.fillRect(x, y, blockSize, blockSize);
      holdCtx.strokeStyle = '#222';
      holdCtx.strokeRect(x, y, blockSize, blockSize);
    }
  }
}

function drawNext() {
  nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
  if (next) {
    const blockSize = 20;
    const offsetX = (nextCanvas.width - 4 * blockSize) / 2;
    const offsetY = (nextCanvas.height - 4 * blockSize) / 2;
    
    for (const [dx, dy] of next.shape[0]) {
      const x = offsetX + dx * blockSize;
      const y = offsetY + dy * blockSize;
      nextCtx.fillStyle = next.color;
      nextCtx.fillRect(x, y, blockSize, blockSize);
      nextCtx.strokeStyle = '#222';
      nextCtx.strokeRect(x, y, blockSize, blockSize);
    }
  }
}

function holdTetromino() {
  if (!current || holdUsed) return;
  
  if (hold) {
    // ÌôÄÎìúÎêú Î∏îÎ°ùÍ≥º ÌòÑÏû¨ Î∏îÎ°ù ÍµêÌôò
    const temp = hold;
    hold = { ...current, rotation: 0, x: 3, y: 0 };
    current = { ...temp, rotation: 0, x: 3, y: 0 };
  } else {
    // ÌôÄÎìúÍ∞Ä ÎπÑÏñ¥ÏûàÏúºÎ©¥ ÌòÑÏû¨ Î∏îÎ°ùÏùÑ ÌôÄÎìúÌïòÍ≥† Îã§Ïùå Î∏îÎ°ù ÏÇ¨Ïö©
    hold = { ...current, rotation: 0, x: 3, y: 0 };
    current = next;
    next = randomTetromino();
  }
  
  holdUsed = true;
  drawHold();
  drawNext();
  drawBoard();
}

function isValidMove(tetro: Tetromino, nx: number, ny: number, nrot: number) {
  for (const [dx, dy] of tetro.shape[nrot]) {
    const x = nx + dx;
    const y = ny + dy;
    if (x < 0 || x >= COLS || y >= ROWS) return false;
    if (y >= 0 && board[y][x] !== null) return false;
  }
  return true;
}

function mergeTetromino() {
  if (!current) return;
  for (const [dx, dy] of current.shape[current.rotation]) {
    const x = current.x + dx;
    const y = current.y + dy;
    if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {
      board[y][x] = current.type;
    }
  }
}

function clearLines() {
  let lines = 0;
  const newBoard: Cell[][] = [];
  
  // ÏôÑÏÑ±ÎêòÏßÄ ÏïäÏùÄ Ï§ÑÎì§Îßå ÏÉà Î∞∞Ïó¥Ïóê Ï∂îÍ∞Ä
  for (let y = ROWS - 1; y >= 0; y--) {
    if (!board[y].every(cell => cell !== null)) {
      newBoard.unshift([...board[y]]);
    } else {
      lines++;
    }
  }
  
  // Îπà Ï§ÑÎì§ÏùÑ ÏúÑÏóê Ï∂îÍ∞Ä
  while (newBoard.length < ROWS) {
    newBoard.unshift(Array(COLS).fill(null));
  }
  
  // board Î∞∞Ïó¥ ÍµêÏ≤¥
  board = newBoard;
  
  if (lines > 0) {
    score += [0, 100, 300, 500, 800][lines];
    scoreEl.textContent = score.toString();
    
    // Ï†êÏàò Î≥ÄÍ≤Ω Ïãú Ï¶âÏãú ÏÉÅÌÉú Ï†ÄÏû• Î∞è ÌîåÎ†àÏù¥Ïñ¥ Î™©Î°ù ÏóÖÎç∞Ïù¥Ìä∏
    saveGameState();
    updatePlayersList();
  }
}

function lockAndNext() {
  if (!current) return;
  
  mergeTetromino();
  clearLines();
  spawnTetromino();
  
  // currentÍ∞Ä ÏÉàÎ°ú Ìï†ÎãπÎêú ÌõÑ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
  if (current && !isValidMove(current, current.x, current.y, current.rotation)) {
    gameOver = true;
    saveGameState(); // Í≤åÏûÑ Ïò§Î≤Ñ ÏÉÅÌÉú Ï¶âÏãú Ï†ÄÏû•
    stopGame();
    alert('Game Over!');
  }
  
  drawBoard();
}

function drop() {
  if (!current) return;
  if (isValidMove(current, current.x, current.y + 1, current.rotation)) {
    current.y++;
    drawBoard();
  } else {
    lockAndNext();
  }
}

function hardDrop() {
  if (!current || gameOver) return;
  
  // ÌÉÄÏù¥Î®∏ ÌôïÏã§Ìûà Ï†ïÎ¶¨
  if (dropTimer) {
    clearTimeout(dropTimer);
    dropTimer = undefined;
  }
  
  // Î∏îÎ°ùÏùÑ Î∞îÎã•ÍπåÏßÄ ÎÇ¥Î¶¨Í∏∞ (drop() Ìò∏Ï∂úÌïòÏßÄ ÏïäÍ≥† ÏßÅÏ†ë)
  while (isValidMove(current, current.x, current.y + 1, current.rotation)) {
    current.y++;
  }
  
  // Î∏îÎ°ùÏùÑ boardÏóê Ï†ÄÏû•ÌïòÍ≥† Ï¶âÏãú Í∑∏Î¶¨Í∏∞
  mergeTetromino();
  drawBoard();
  
  // Ï§Ñ ÏÇ≠Ï†ú
  clearLines();
  drawBoard();
  
  // Îã§Ïùå Î∏îÎ°ù ÏÉùÏÑ±
  spawnTetromino();
  drawBoard();
  
  // Í≤åÏûÑ Ïò§Î≤Ñ Ï≤¥ÌÅ¨
  if (current && !isValidMove(current, current.x, current.y, current.rotation)) {
    gameOver = true;
    saveGameState(); // Í≤åÏûÑ Ïò§Î≤Ñ ÏÉÅÌÉú Ï¶âÏãú Ï†ÄÏû•
    stopGame();
    alert('Game Over!');
  } else {
    // Í≤åÏûÑÏù¥ Í≥ÑÏÜç ÏßÑÌñâ Ï§ëÏù¥Î©¥ ÌÉÄÏù¥Î®∏ Ïû¨ÏãúÏûë
    dropTimer = window.setTimeout(gameLoop, dropInterval);
  }
}

function move(dx: number) {
  if (!current) return;
  if (isValidMove(current, current.x + dx, current.y, current.rotation)) {
    current.x += dx;
    drawBoard();
  }
}

function rotate() {
  if (!current) return;
  const nextRot = (current.rotation + 1) % 4;
  if (isValidMove(current, current.x, current.y, nextRot)) {
    current.rotation = nextRot;
    drawBoard();
  }
}

function spawnTetromino() {
  current = next || randomTetromino();
  next = randomTetromino();
  holdUsed = false; // ÏÉàÎ°úÏö¥ Î∏îÎ°ùÏù¥ ÏÉùÏÑ±ÎêòÎ©¥ ÌôÄÎìú ÏÇ¨Ïö© Í∞ÄÎä•
  drawNext();
}

function gameLoop() {
  if (gameOver) return;
  drop();
  dropTimer = window.setTimeout(gameLoop, dropInterval);
}

function startGame() {
  resetBoard();
  score = 0;
  scoreEl.textContent = '0';
  gameOver = false;
  hold = null;
  holdUsed = false;
  dropInterval = 500;
  spawnTetromino();
  drawBoard();
  drawHold();
  drawNext();
  if (dropTimer) clearTimeout(dropTimer);
  dropTimer = window.setTimeout(gameLoop, dropInterval);
  
  // Ï∫îÎ≤ÑÏä§Ïóê Ìè¨Ïª§Ïä§Î•º Ï£ºÏñ¥ ÌÇ§Î≥¥Îìú Ïù¥Î≤§Ìä∏Í∞Ä Ï¶âÏãú Í∞êÏßÄÎêòÎèÑÎ°ù Ìï®
  canvas.focus();
  
  // Í≤åÏûÑ ÏãúÏûë ÏãúÍ∞Ñ Í∏∞Î°ù
  if (players[playerId]) {
    players[playerId].gameStartTime = Date.now();
  }
  
  // Í≤åÏûÑ ÏãúÏûë Ïãú ÏÉÅÌÉú Í≥µÏú† Î∞è ÌîåÎ†àÏù¥Ïñ¥ Î™©Î°ù ÏóÖÎç∞Ïù¥Ìä∏ (Ï¶âÏãú Ïã§Ìñâ)
  setTimeout(() => {
    saveGameState();
    updatePlayersList();
  }, 0);
}

function stopGame() {
  if (dropTimer) clearTimeout(dropTimer);
  
  // Í≤åÏûÑ Ïò§Î≤Ñ ÏÉÅÌÉú Ï†ÄÏû•
  if (gameOver) {
    saveGameState();
  }
  
  stopGameStateSharing();
}

// ÌÇ§Î≥¥Îìú Ïù¥Î≤§Ìä∏
window.addEventListener('keydown', (e) => {
  if (!current || gameOver) return;
  
  // Í≤åÏûÑ Í¥ÄÎ†® ÌÇ§Îäî Í∏∞Î≥∏ ÎèôÏûë Î∞©ÏßÄ
  if (['ArrowLeft', 'ArrowRight', 'ArrowDown', 'ArrowUp', ' ', 'x', 'X'].includes(e.key)) {
    e.preventDefault();
  }
  
  switch (e.key) {
    case 'ArrowLeft':
      move(-1);
      break;
    case 'ArrowRight':
      move(1);
      break;
    case 'ArrowDown':
      drop();
      break;
    case 'ArrowUp':
      rotate();
      break;
    case ' ': // space
      hardDrop();
      break;
    case 'x': // x for hold
    case 'X': // ÎåÄÎ¨∏Ïûê XÎèÑ ÏßÄÏõê
      holdTetromino();
      break;
  }
});

startBtn.addEventListener('click', startGame);

// Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
createRoomBtn.addEventListener('click', createRoom);
joinRoomBtn.addEventListener('click', () => {
  const roomInputGroup = document.getElementById('room-input-group')!;
  roomInputGroup.style.display = 'block';
  
  // URLÏóê Î∞© ÏΩîÎìúÍ∞Ä ÏûàÏúºÎ©¥ ÏûêÎèôÏúºÎ°ú Ï±ÑÏö∞Í∏∞
  const urlParams = new URLSearchParams(window.location.search);
  const roomFromUrl = urlParams.get('room');
  if (roomFromUrl && roomCodeInput) {
    roomCodeInput.value = roomFromUrl;
  }
});

// Î∞© Ï∞∏Í∞Ä Ï†úÏ∂ú Î≤ÑÌäºÏóê Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï∂îÍ∞Ä
joinRoomSubmitBtn.addEventListener('click', joinRoom);

// Î∞© ÏΩîÎìú ÏûÖÎ†• ÌïÑÎìúÏóêÏÑú Enter ÌÇ§Î°ú Ï∞∏Í∞Ä
roomCodeInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    joinRoom();
  }
});

shareBtn.addEventListener('click', () => {
  if (roomId) {
    const url = `${window.location.origin}${window.location.pathname}?room=${roomId}`;
    navigator.clipboard.writeText(url).then(() => {
      alert('Room link copied to clipboard!');
    }).catch(() => {
      prompt('Copy this room link:', url);
    });
  }
});

// Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Ìï®ÏàòÎì§ (WebSocket Ï†úÍ±∞)
function generateRoomId(): string {
  return Math.random().toString(36).substring(2, 8).toUpperCase();
}

async function createRoom() {
  if (!nicknameInput.value.trim()) {
    alert('Please enter a nickname');
    return;
  }
  
  playerName = nicknameInput.value.trim();
  playerNameEl.textContent = playerName;
  
  roomId = generateRoomId();
  roomIdEl.textContent = roomId;
  
  // WebRTC ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÉùÏÑ± Î∞è Ïó∞Í≤∞
  webrtcClient = new WebRTCClient(
    playerId,
    roomId,
    playerName,
    handleGameStateUpdate,
    handlePlayerListUpdate
  );
  
  try {
    await webrtcClient.connect(SIGNALING_SERVER_URL);
    console.log('Connected to signaling server');
    
    players[playerId] = {
      name: playerName,
      board: Array.from({ length: ROWS }, () => Array(COLS).fill(null)),
      score: 0,
      current: null,
      next: null,
      gameOver: false
    };
    
    hideRoomModal();
    updateRoomInfo();
    updatePlayersList();
    
    // URL ÏóÖÎç∞Ïù¥Ìä∏
    updateURL();
    
    // Í≤åÏûÑ ÏÉÅÌÉú Í≥µÏú† ÏãúÏûë
    startGameStateSharing();
    
    console.log(`Room created: ${roomId}`);
  } catch (error) {
    console.error('Failed to connect to signaling server:', error);
    alert('Failed to connect to server. Please try again.');
  }
}

async function joinRoom() {
  if (!nicknameInput.value.trim() || !roomCodeInput.value.trim()) {
    alert('Please enter nickname and room code');
    return;
  }
  
  playerName = nicknameInput.value.trim();
  roomId = roomCodeInput.value.trim().toUpperCase();
  
  playerNameEl.textContent = playerName;
  roomIdEl.textContent = roomId;
  
  // WebRTC ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÉùÏÑ± Î∞è Ïó∞Í≤∞
  webrtcClient = new WebRTCClient(
    playerId,
    roomId,
    playerName,
    handleGameStateUpdate,
    handlePlayerListUpdate
  );
  
  try {
    await webrtcClient.connect(SIGNALING_SERVER_URL);
    console.log('Connected to signaling server');
    
    // ÌîåÎ†àÏù¥Ïñ¥ Ï†ïÎ≥¥ Ï¥àÍ∏∞Ìôî
    players[playerId] = {
      name: playerName,
      board: Array.from({ length: ROWS }, () => Array(COLS).fill(null)),
      score: 0,
      current: null,
      next: null,
      gameOver: false
    };
    
    hideRoomModal();
    updateRoomInfo();
    updatePlayersList();
    
    // URL ÏóÖÎç∞Ïù¥Ìä∏
    updateURL();
    
    // Í≤åÏûÑ ÏÉÅÌÉú Í≥µÏú† ÏãúÏûë
    startGameStateSharing();
    
    console.log(`Joined room: ${roomId}`);
  } catch (error) {
    console.error('Failed to connect to signaling server:', error);
    alert('Failed to connect to server. Please try again.');
  }
}

function hideRoomModal() {
  roomModalEl.classList.add('hidden');
}

function showRoomModal() {
  roomModalEl.classList.remove('hidden');
}

function updateRoomInfo() {
  const url = `${window.location.origin}${window.location.pathname}?room=${roomId}`;
  // URLÏùÑ ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóê Î≥µÏÇ¨ÌïòÍ±∞ÎÇò Í≥µÏú† Í∏∞Îä• Íµ¨ÌòÑ
}

function updateURL() {
  const url = new URL(window.location.href);
  url.searchParams.set('room', roomId);
  url.searchParams.set('player', playerId);
  url.searchParams.set('name', playerName);
  window.history.replaceState({}, '', url.toString());
}

function updatePlayersList() {
  // ÏûêÏã†Ïùò Ï†êÏàòÎ•º players Í∞ùÏ≤¥Ïóê ÏóÖÎç∞Ïù¥Ìä∏
  if (players[playerId]) {
    players[playerId].score = score;
  }
  
  playersListEl.innerHTML = '';
  Object.entries(players).forEach(([id, player]) => {
    const playerItem = document.createElement('div');
    playerItem.className = `p-3 rounded-lg border transition-all duration-200 ${
      id === playerId 
        ? 'bg-gradient-to-r from-green-600 to-blue-600 text-white border-green-500 shadow-lg' 
        : 'glass-effect text-white/90 border-white/20 hover:bg-white/10'
    }`;
    playerItem.innerHTML = `
      <div class="font-bold text-lg">${player.name}</div>
      <div class="text-sm opacity-80">Score: ${player.score}</div>
    `;
    playersListEl.appendChild(playerItem);
  });
  
  // Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Í≤åÏûÑ Ï§ëÏù∏ÏßÄ ÌôïÏù∏ÌïòÏó¨ ÏãúÏûë Î≤ÑÌäº Ï†úÏñ¥
  checkGameStartAvailability();
}

function checkGameStartAvailability() {
  const startBtn = document.getElementById('start-btn') as HTMLButtonElement;
  if (!startBtn) return;
  
  // Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥ Ï§ë Í≤åÏûÑ Ï§ëÏù∏ ÏÇ¨ÎûåÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
  let otherPlayerPlaying = false;
  let hasOtherPlayers = false;
  let timeoutExpired = false;
  const currentTime = Date.now();
  
  Object.entries(players).forEach(([id, player]) => {
    if (id !== playerId) {
      hasOtherPlayers = true;
      // Í≤åÏûÑ Ï§ëÏù¥Í±∞ÎÇò Í≤åÏûÑ Ïò§Î≤ÑÍ∞Ä ÏïÑÎãå ÏÉÅÌÉúÎ©¥ Í≤åÏûÑ Ï§ëÏúºÎ°ú Í∞ÑÏ£º
      if (player.current && !player.gameOver) {
        otherPlayerPlaying = true;
        // Í≤åÏûÑ ÏãúÏûë ÏãúÍ∞ÑÏù¥ ÏûàÍ≥†, ÌÉÄÏûÑÏïÑÏõÉÏù¥ ÏßÄÎÇ¨ÎäîÏßÄ ÌôïÏù∏
        if (player.gameStartTime && (currentTime - player.gameStartTime) > GAME_START_TIMEOUT) {
          timeoutExpired = true;
        }
      }
    }
  });
  
  // Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥Í∞Ä ÏóÜÏúºÎ©¥ ÏãúÏûë Í∞ÄÎä•
  if (!hasOtherPlayers) {
    startBtn.disabled = false;
    startBtn.textContent = 'Start';
    startBtn.style.opacity = '1';
    return;
  }
  
  // Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥Í∞Ä ÏûàÍ≥†, ÌÉÄÏûÑÏïÑÏõÉÏù¥ ÏßÄÎÇ¨ÏúºÎ©¥ ÏãúÏûë Î∂àÍ∞Ä
  if (timeoutExpired) {
    startBtn.disabled = true;
    startBtn.textContent = 'Too late to join...';
    startBtn.style.opacity = '0.5';
    return;
  }
  
  // 10Ï¥à Ïù¥ÎÇ¥ÎùºÎ©¥ Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Í≤åÏûÑ Ï§ëÏù¥Ïñ¥ÎèÑ ÏãúÏûë Í∞ÄÎä•
  startBtn.disabled = false;
  startBtn.textContent = 'Start';
  startBtn.style.opacity = '1';
}

function createOtherPlayerCanvas(playerId: string) {
  const playerDiv = document.createElement('div');
  playerDiv.className = 'tetris-panel p-2 flex flex-col items-center';
  
  const playerName = document.createElement('div');
  playerName.className = 'text-xs font-bold text-white mb-1 text-center bg-gradient-to-r from-green-600 to-blue-600 px-1 py-0.5 rounded';
  playerName.textContent = players[playerId].name;
  
  const canvas = document.createElement('canvas');
  canvas.className = 'tetris-canvas mx-auto shadow-lg';
  
  // Ï¥àÍ∏∞ ÌÅ¨Í∏∞ ÏÑ§Ï†ï (Ïò§Î•∏Ï™Ω Ìå®ÎÑêÏóê ÎßûÍ≤å ÏûëÍ≤å)
  canvas.width = 60;
  canvas.height = 120;
  canvas.style.width = '60px';
  canvas.style.height = '120px';
  
  playerDiv.appendChild(playerName);
  playerDiv.appendChild(canvas);
  otherPlayersGridEl.appendChild(playerDiv);
  
  otherPlayerCanvases[playerId] = canvas;
  
  // ÎèôÏ†ÅÏúºÎ°ú Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ Ï°∞Ï†à
  setTimeout(() => updateOtherPlayersLayout(), 100);
  
  // Ï¶âÏãú Îπà Î≥¥Îìú Í∑∏Î¶¨Í∏∞
  const ctx = canvas.getContext('2d')!;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Îπà Î≥¥Îìú Í∑∏Î¶¨Í∏∞ (ÌÖåÎëêÎ¶¨Îßå)
  const blockSize = canvas.width / COLS;
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 1;
  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      ctx.strokeRect(x * blockSize, y * blockSize, blockSize, blockSize);
    }
  }
}

// Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥Îì§Ïùò Î†àÏù¥ÏïÑÏõÉÏùÑ ÎèôÏ†ÅÏúºÎ°ú Ï°∞Ï†à
function updateOtherPlayersLayout() {
  const playerCount = Object.keys(otherPlayerCanvases).length;
  if (playerCount === 0) return;
  
  // Ïò§Î•∏Ï™Ω Ìå®ÎÑêÏóê ÎßûÎäî Í∑∏Î¶¨Îìú Î†àÏù¥ÏïÑÏõÉ (ÏÑ∏Î°úÎ°ú Î∞∞Ïπò)
  otherPlayersGridEl.className = `grid gap-2`;
  otherPlayersGridEl.style.gridTemplateColumns = '1fr';
  
  // Í∞Å Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ Ï°∞Ï†à (Ïò§Î•∏Ï™Ω Ìå®ÎÑêÏóê ÎßûÍ≤å ÏûëÍ≤å)
  const containerWidth = otherPlayersGridEl.clientWidth || 180; // Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
  const baseWidth = Math.min(80, containerWidth - 16); // Ìå®Îî© Í≥†Î†§
  const baseHeight = (baseWidth * 20) / 10; // 10:20 ÎπÑÏú® Ïú†ÏßÄ
  
  Object.values(otherPlayerCanvases).forEach(canvas => {
    canvas.width = baseWidth;
    canvas.height = baseHeight;
    canvas.style.width = `${baseWidth}px`;
    canvas.style.height = `${baseHeight}px`;
  });
}

function removeOtherPlayerCanvas(playerId: string) {
  const canvas = otherPlayerCanvases[playerId];
  if (canvas && canvas.parentElement) {
    canvas.parentElement.remove();
  }
  delete otherPlayerCanvases[playerId];
  
  // Î†àÏù¥ÏïÑÏõÉ Ïû¨Ï°∞Ï†ï
  updateOtherPlayersLayout();
}

function updateOtherPlayerGame(playerId: string, gameState: any) {
  const canvas = otherPlayerCanvases[playerId];
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d')!;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥Ïùò Í≤åÏûÑ ÏÉÅÌÉúÎ•º Í∑∏Î¶¨Í∏∞
  const { board, current, score, gameOver } = gameState;
  
  // Í≤åÏûÑ Ïò§Î≤Ñ ÏÉÅÌÉúÎ©¥ "GAME OVER" ÌÖçÏä§Ìä∏ ÌëúÏãú
  if (gameOver) {
    // Î∞òÌà¨Î™Ö Í≤ÄÏùÄ Î∞∞Í≤Ω
    ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Îπ®Í∞ÑÏÉâ "GAME OVER" ÌÖçÏä§Ìä∏
    ctx.fillStyle = '#ff4444';
    ctx.font = 'bold 20px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 15);
    
    // Ìù∞ÏÉâ Ï†êÏàò ÌÖçÏä§Ìä∏
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 14px Arial';
    ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2 + 15);
    
    // Îπ®Í∞ÑÏÉâ ÌÖåÎëêÎ¶¨ Ï∂îÍ∞Ä
    ctx.strokeStyle = '#ff4444';
    ctx.lineWidth = 3;
    ctx.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);
    
    return;
  }
  
  // Î≥¥Îìú Í∑∏Î¶¨Í∏∞ (Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥ Ï∫îÎ≤ÑÏä§Îäî Îçî ÏûëÏúºÎØÄÎ°ú Î∏îÎ°ù ÌÅ¨Í∏∞ Ï°∞Ï†ï)
  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      if (board[y][x] !== null) {
        const blockSize = canvas.width / COLS;
        ctx.fillStyle = COLORS[board[y][x]!];
        ctx.fillRect(x * blockSize, y * blockSize, blockSize, blockSize);
        ctx.strokeStyle = '#222';
        ctx.strokeRect(x * blockSize, y * blockSize, blockSize, blockSize);
      }
    }
  }
  
  // ÌòÑÏû¨ Î∏îÎ°ù Í∑∏Î¶¨Í∏∞
  if (current) {
    const blockSize = canvas.width / COLS;
    for (const [dx, dy] of current.shape[current.rotation]) {
      const px = current.x + dx;
      const py = current.y + dy;
      if (py >= 0 && py < ROWS && px >= 0 && px < COLS) {
        ctx.fillStyle = current.color;
        ctx.fillRect(px * blockSize, py * blockSize, blockSize, blockSize);
        ctx.strokeStyle = '#222';
        ctx.strokeRect(px * blockSize, py * blockSize, blockSize, blockSize);
      }
    }
  }
}

function saveGameState() {
  if (!webrtcClient || !roomId) return;
  
  const gameState: GameState = {
    playerId,
    playerName,
    board,
    current,
    next,
    score,
    gameOver,
    timestamp: Date.now(),
    gameStartTime: players[playerId]?.gameStartTime
  };
  
  webrtcClient.sendGameState(gameState);
}

// WebRTCÎ•º ÌÜµÌïú Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ Ìï∏Îì§Îü¨
function handleGameStateUpdate(peerId: string, gameState: GameState) {
  if (peerId === playerId) return; // ÏûêÏã†Ïùò ÏÉÅÌÉúÎäî Î¨¥Ïãú
  
  // Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥ Ï†ïÎ≥¥ Ï∂îÍ∞Ä/ÏóÖÎç∞Ïù¥Ìä∏
  if (!players[peerId]) {
    players[peerId] = {
      name: gameState.playerName || 'Player',
      board: Array.from({ length: ROWS }, () => Array(COLS).fill(null)),
      score: 0,
      current: null,
      next: null,
      gameOver: false
    };
    createOtherPlayerCanvas(peerId);
    updatePlayersList();
  }
  
  // Í≤åÏûÑ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
  if (gameState.gameOver) {
    // Í≤åÏûÑ Ïò§Î≤Ñ ÏÉÅÌÉúÎ©¥ Î≥¥ÎìúÎ•º Ï¥àÍ∏∞ÌôîÌïòÍ≥† ÌòÑÏû¨ Î∏îÎ°ù Ï†úÍ±∞
    players[peerId].board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
    players[peerId].current = null;
    players[peerId].score = gameState.score;
    players[peerId].gameOver = true;
    players[peerId].gameStartTime = undefined;
  } else {
    // Í≤åÏûÑ ÏßÑÌñâ Ï§ëÏù¥Î©¥ Ï†ïÏÉÅÏ†ÅÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏
    players[peerId].board = gameState.board;
    players[peerId].score = gameState.score;
    players[peerId].current = gameState.current;
    players[peerId].gameOver = false;
    if (gameState.gameStartTime) {
      players[peerId].gameStartTime = gameState.gameStartTime;
    }
  }
  
  updateOtherPlayerGame(peerId, gameState);
  updatePlayersList();
  checkGameStartAvailability();
}

// WebRTCÎ•º ÌÜµÌïú ÌîåÎ†àÏù¥Ïñ¥ Î™©Î°ù ÏóÖÎç∞Ïù¥Ìä∏ Ìï∏Îì§Îü¨
function handlePlayerListUpdate(playerList: Array<{playerId: string, playerName: string}>) {
  // ÌòÑÏû¨ Ïó∞Í≤∞Îêú ÌîåÎ†àÏù¥Ïñ¥Îì§Îßå Ïú†ÏßÄ
  const currentPlayerIds = new Set(playerList.map(p => p.playerId));
  
  // Ïó∞Í≤∞Ïù¥ ÎÅäÏñ¥ÏßÑ ÌîåÎ†àÏù¥Ïñ¥Îì§ Ï†úÍ±∞
  Object.keys(players).forEach(pid => {
    if (pid !== playerId && !currentPlayerIds.has(pid)) {
      removeOtherPlayerCanvas(pid);
      delete players[pid];
    }
  });
  
  updatePlayersList();
}

function startGameStateSharing() {
  // Ï£ºÍ∏∞Ï†ÅÏúºÎ°ú Í≤åÏûÑ ÏÉÅÌÉú Ï†ÄÏû• (WebRTCÎ•º ÌÜµÌï¥)
  gameStateInterval = setInterval(() => {
    saveGameState();
  }, 100); // 0.1Ï¥àÎßàÎã§ ÏóÖÎç∞Ïù¥Ìä∏ (Îçî Îπ†Î•∏ Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî)
}

function stopGameStateSharing() {
  if (gameStateInterval) {
    clearInterval(gameStateInterval);
    gameStateInterval = null;
  }
}

// Ï¥àÍ∏∞Ìôî
function initMultiplayer() {
  // URLÏóêÏÑú Î∞© ID ÌôïÏù∏
  const urlParams = new URLSearchParams(window.location.search);
  const roomFromUrl = urlParams.get('room');
  const playerFromUrl = urlParams.get('player');
  const nameFromUrl = urlParams.get('name');

  if (roomFromUrl) {
    // Î∞© ÎßÅÌÅ¨Î°ú Ï†ëÏÜçÌïú Í≤ΩÏö∞
    roomCodeInput.value = roomFromUrl;
    roomId = roomFromUrl;
    roomIdEl.textContent = roomId;
    
    if (playerFromUrl && nameFromUrl) {
      // Í∏∞Ï°¥ ÌîåÎ†àÏù¥Ïñ¥Î°ú Î≥µÍ∑Ä
      playerId = playerFromUrl;
      playerName = nameFromUrl;
      playerNameEl.textContent = playerName;
      
      // WebRTC ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïû¨Ïó∞Í≤∞
      webrtcClient = new WebRTCClient(
        playerId,
        roomId,
        playerName,
        handleGameStateUpdate,
        handlePlayerListUpdate
      );
      
      webrtcClient.connect(SIGNALING_SERVER_URL).then(() => {
        hideRoomModal();
        startGameStateSharing();
      }).catch((error) => {
        console.error('Failed to reconnect:', error);
        showRoomModal();
      });
    } else {
      // ÏÉà ÌîåÎ†àÏù¥Ïñ¥Î°ú Ï∞∏Í∞Ä
      showRoomModal();
    }
  } else {
    // ÏÉàÎ°ú Ï†ëÏÜçÌïú Í≤ΩÏö∞
    showRoomModal();
  }

  // ÌîåÎ†àÏù¥Ïñ¥ ID ÏÉùÏÑ± (URLÏóê ÏóÜÏúºÎ©¥)
  if (!playerId) {
    playerId = Math.random().toString(36).substring(2, 15);
  }
}

// ÏµúÏ¥à ÌôîÎ©¥
resetBoard();
drawBoard();
drawHold();
drawNext();

// ÏúàÎèÑÏö∞ Î¶¨ÏÇ¨Ïù¥Ï¶à Ïãú Î†àÏù¥ÏïÑÏõÉ ÏóÖÎç∞Ïù¥Ìä∏
window.addEventListener('resize', () => {
  updateOtherPlayersLayout();
});

// Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Ï¥àÍ∏∞Ìôî
initMultiplayer();

